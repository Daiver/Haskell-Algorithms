Еще Одно Руководство по Монадам (часть 4: Монада Maybe)
Mike Vanier
http://mvanier.livejournal.com

Перевод: Гранин А. С.
graninas@gmail.com

В предыдущих статьях этой серии мы изучали концептуальный базис монад, но обсуждение наше было слишком абстрактным. Теперь, когда вы, я надеюсь, поняли, что монады такое и для чего они нужны, пришло время перейти к детальному рассмотрению специфических монад. Это значит, что мы определим корректные воплощения класса типов Monad для множества различных понятий вычислений, которые мы увидели раньше. Мы используем наши знания, чтобы получить монадическую композицию в каждом конкретном случае через монадическое применение (оператор >>=), и с помощью монадных законов мы выведем определение return.

Монада Maybe

Монаду Maybe обычно первой представляют в руководствах по Haskell, потому что она очень проста в использовании, реализации и понимании. Для начала взглянем на определение типа данных Maybe:

data Maybe a = Nothing | Just a

Здесь указано, что Maybe - это конструктор типа, в который помещается определенный тип |a|, чтобы получить (конкретный) тип данных. Обычно говорят, что Maybe - это "полиморфный" тип данных, смысл тот же. Так, если бы |a| был Int, мы бы получили:

data Maybe Int = Nothing | Just Int

Только вот нам не нужно это писать непосредственно, так как абстрактное определение выше подходит ко всем типам.

Значение типа Maybe a может либо быть, либо отсутствовать. Если значение Nothing ("Ничто"), то его "как бы и нет", а если оно Just x для некоторого значения x, то это "просто" значение x. Можно думать об этом как о контейнере, в котором либо 0 элементов, либо он один. (Вспомните: я когда-то говорил, что монадические значения иногда ошибочно представляются в виде контейнеров. Это тот самый случай.)

Полиморфный тип Maybe полезен тем, что мы можем использовать его как модель "расширенной функции", которая либо производит что-то как выходное значение, либо терпит в этом крах и не может вернуть никакое значение. (То есть, такая функция может провалиться.) Это можно записать так:

f :: a -> Maybe b

Функция f берет значение типа a и либо возвращает Nothing (признак неудачи), либо значение Just x, где у x тип b. Функции вроде f будут работать в монаде Maybe, и композиция двух таких функций выглядит следующим образом:

f :: a -> Maybe b   -- предполагаем, что f где-то определена
g :: b -> Maybe c   -- предполагаем, что g где-то определена

h :: a -> Maybe c   -- монадическая композиция f и g
h = f >=> g         -- вспомним: >=> - это оператор монадической композиции

Мы говорили, что все монады должны быть конструкторами типов. Maybe - это конструктор типа, так что тут все хорошо. Но для того чтобы Maybe стал монадой, нам нужно создать экземпляр класса типов Monad, а это значит, что мы должны заполнить следующее определение:

instance Monad Maybe where
  (>>=)  = {- определение >>= для Maybe -}
  return = {- определение return для Maybe -}

Как мы можем задать (>>=) и return для Maybe?

Сначала напишем каркас определения для >>=, покрывающий два возможных случая левого операнда типа Maybe a:

Nothing >>= f  =  {- нужно дописать -}
Just x  >>= f  =  {- нужно дописать -}

где x имеет тип a. Левую часть определения можно написать и подругому:

(>>=) Nothing  f  =  {- нужно дописать -}
(>>=) (Just x) f  =  {- нужно дописать -}

Но лучше все-таки, если оператор (>>=) задан как оператор, а не как функция, и Haskell нам это позволяет.

Для завершения этого определения подумаем, что мы хотим получить от монадической композиции в монаде Maybe. Давайте возьмем наш пример с функциями f и g, монадически их скомпонуем и получим функцию h:

f :: a -> Maybe b
g :: b -> Maybe c
h :: a -> Maybe c
h = f >=> g

Если мы передадим аргумент в функцию f, и она вернет Nothing (то есть, потерпит неудачу), тогда что должна вернуть функция h?

f x = Nothing
h x = (f >=> g) x = ???

Кажется очевидным, что если f x вернет Nothing, то и h тоже должна вернуть Nothing, поскольку если часть выражения (функция f) не смогла вернуть результат, то и все выражение (функция h) не сможет его вернуть. Единственный вариант, когда h возвращает значение, это когда f вернет результат (назовем его y), он будет передан функции g, и g y тоже вернет результат. Если провалится f или g, то и h тоже завершится неудачей, то есть, вычислением h x будет Nothing.

Имея это в виду, из нашего определения h получим:

h = f >=> g
h = \x -> (f x >>= g)  -- эквивалент (из определения >=>)
h x = f x >>= g        -- эквивалент
-- предположим, что f x == Nothing
h x = (Nothing >>= g)
    = Nothing
-- таким образом:
Nothing >>= g = Nothing

Теперь мы знаем, как оператор (>>=) реагирует на аргумент Nothing, - он просто возвращает тот же Nothing:

Nothing >>= f  =  Nothing
Just x  >>= f  =  {- нужно дописать -}

Обратите внимание, я здесь заменил g на f, и это корректно, ведь имена функций не важны здесь. На практике мы вообще избавляемся от имен функций, если это возможно, и заменяем их специальным оператором _ (нижнее подчеркивание), вот так:

Nothing >>= _  =  Nothing

Со вторым уравнением этого сделать нельзя, потому что функцию f мы еще будем использовать в определении.

Теперь давайте подойдем с другой стороны. Если f x _не_ провалится, результатом будет значение Just y для некоторого y. Нам нужно "распаковать" значение y из Just y, которое мы бы потом передали функции g, и g y - это результат всей функции h:

h = f >=> g
h = \x -> (f x >>= g)  -- эквивалент (из определения >=>)
h x = f x >>= g        -- эквивалент
-- предположим, что f x == Just y 
h x = (Just y >>= g)
    = g y

Что дает нам вторую часть определения:

Nothing >>= f  =  Nothing
Just x  >>= f  =  f x

Заметьте, что я заменил y на x и g на f. Опять же, имена переменных и функций не имеют значения до тех пор, пока вы последовательны.

На этом завершается определение оператора >>= для монады Maybe. Теперь нам нужно получить return для этой монады:

return x  =  ???

для любого значения x. Какие у нас есть варианты? Мы могли бы просто сказать, что

return x  =  Nothing

для любого x. Однако мы бы нарушили монадные законы, если бы так сделали:

return x >>= f  ==  f x
Nothing >>=  f  ==  f x
Nothing         ==  f x   -- НЕВЕРНО!

Предполагая, что по крайней мере _некоторые_ f x не Nothing (например, рассмотрим монадическую функцию f x = Just x), получим ошибку. Есть и другой вариант:

return x  =  Just x

и он удовлетворяет монадным законам:

return x >>= f
  = (Just x) >>= f   -- по определению return для монады Maybe
  = f x              -- по определению >>= для монады Maybe
                     -- выполнение первого монадного закона

Just x >>= return
  = return x         -- по определению >>= для монады Maybe
  = Just x           -- по определению return для монады Maybe
                     -- выполнение второго монадного закона

Nothing >>= return
  = Nothing          -- по определению >>= для монады Maybe
                     -- выполнение второго монадного закона

Раз законы соблюдаются, этот вариант и возьмем. Полное определение монады Maybe выглядит так:

instance Monad Maybe where
  return x  =  Just x

  Nothing >>= f  =  Nothing
  Just x  >>= f  =  f x

Вау! Мы только что создали нашу первую монаду!

Просто чтобы обезопасить себя, проверим, что она удовлетворяет третьему монадному закону, который гласит:

(mv >>= f) >>= g    ==    mv >>= (\x -> (f x >>= g))

Сначала проверим закон для случая, когда mv = Nothing:

(Nothing >>= f) >>= g             -- с левой стороны
  = Nothing >>= g                 -- по определению >>=
  = Nothing                       -- по определению >>=

Nothing >>= (\x -> (f x >>= g))   -- с правой стороны
  = Nothing                       -- по определению >>=

Хорошо, проверка прошла успешно. Теперь посмотрим, работает ли для mv = Just v, где v - некоторое значение:

((Just v) >>= f) >>= g            -- с левой стороны
  = f v >>= g                     -- по определению >>=

(Just v) >>= (\x -> (f x >>= g))  -- с правой стороны
  = (\x -> (f x >>= g)) v         -- по определению >>=
  = f v >>= g                     -- нормальное применение функции (бета-редукция)

И тоже успешно. Значит, это работает! Это _действительно_ правильное определение монады Maybe! И публика сходит с ума!

В чем смысл всего этого? Это значит, что теперь мы легко можем соединить кучу монадических функций монады Maybe. Вы, возможно, задаетесь вопросом, почему это важно? Совсем нетрудно представить себе кучу монадических функций в монаде Maybe, то есть, таких, которые могут провалиться. Скажем, пусть у них будет тип |Int -> Maybe Int|. Вот три подобных функции:

f :: Int -> Maybe Int
f x = if x `mod` 2 == 0 then Nothing else Just (2 * x)

g :: Int -> Maybe Int
g x = if x `mod` 3 == 0 then Nothing else Just (3 * x)

h :: Int -> Maybe Int
h x = if x `mod` 5 == 0 then Nothing else Just (5 * x)

Нам бы хотелось соединить их в одну функцию, которая есть результат применения по порядку f, g, h:

k :: Int -> Maybe Int

И если какая-то из трех функций потерпит неудачу, функция k должна вернуть Nothing. Эта функция умножает входное число на 30, если оно не делится целочисленно на 2, 3 или 5 (а если делится, функция возвращает Nothing).

Из предыдущего материала, если вы его хорошо поняли, должно быть понятно, что вы можете задать k через монадическую композицию:

k = f >=> g >=> h

Или можете взять оператор >>=:

k x = f x >>= g >>= h

Или, возможно, вам нравится |do|-нотация:

k x = do y <- f x
         z <- g y
         h z

Это просто, как ни крути. {1: В оригинале - устойчивое выражение "Any way you slice it", аналогичное по смыслу. - Прим. пер.}

А вообще, функцию h можно определить вовсе без монадных конструкций, это будет выглядеть так:

k x = case f x of
        Nothing -> Nothing
        Just y  -> case g y of
                     Nothing -> Nothing
                     Just z  -> h z

Теперь понятно, почему монада Maybe важна. Она резко упрощает код, соединяя в цепь несколько Maybe-функций. Представьте, какой грубый немонадический код получился бы при композиции десяти Maybe-функций в таком виде. Получился бы такой большой отступ вправо, что читаемость сильно пострадала бы, и общая структура вычислений потерялась бы в лабиринте вложенных case-выражений. Но с помощью монад композиция десяти функций записывается просто:

f11 = f1 >=> f2 >=> f3 >=> f4 >=> f5 >=> f6 >=> f7 >=> f8 >=> f9 >=> f10

или (с использованием >>=):

f11 x = f1 x >>= f2 >>= f3 >>= f4 >>= f5 >>= f6 >>= f7 >>= f8 >>= f9 >>= f10

С помощью монад композиция монадических функций такая же простая, как композиция обычных (немонадических) функций.

Монада Maybe очень полезна для пояснения базовых концепций, но она может сбить с толку: многие люди ошибочно верят, что единственная роль монад в обработке нефункциональных вычислений, то есть, тех вычислений, которые работают с вводом/выводом (с консолью или с файлом), с изменяемым глобальным состоянием, и так далее. А я показал, что некоторые монадические вычисления могут быть с тем же успехом выполнены совсем без монад. Получается, что монады не что-то обязательное, они просто _очень_ удобны. Именно поэтому я говорил, что даже несмотря на _первоначальную_ причину изобретения монад для нефункциональных вычислений (работа с IO), у них, как оказалось, гораздо большая применимость. Из-за этого монады хороши.

А теперь перейдем к следующей монаде.

Монада list (список)

Если монада Maybe вам просто понравилась, то монаду list вы даже полюбите. ;-) В данном случае мы заполним следующее определение:

instance Monad [] where
  (>>=)  = {- definition of >>= for lists -}
  return = {- definition of return for lists -}

Заметьте, что для представления пустого списка [] мы используем списковый конструктор типа. Это небольшой хак (для списков в Haskell вшита специальная синтаксическая поддержка). Но ничего не поделаешь.

Как и для всех монад, первой задачей будет понять, что представляют из себя монадические функции этой монады. Для списка монадическая функция |f| выглядит так:

f :: a -> [b]

(где |[b]| значит, конечно, "список элементов типа |b|"). Вспомните, что обобщенное определение монадической функции записывается следующим образом:

f :: a -> m b

для некоторой монады m, которая должна быть конструктором типа. Список - очевидный кандидат в монаду, поскольку "список из" - это конструктор типа (пусть даже его синтаксис жестко зашит в Haskell); по желанию, мы могли бы определить список сами:

data List a = Nil | Cons a (List a)

Тип монадическая функций для него выглядел бы соответственно:

f :: a -> List b

Но мы будем все-таки придерживаться стандартного синтаксиса.

Чем являются функции подобного сорта? Обычно их понимают как функции, которые берут входное значение типа |a| и производят кучу значений типа |b|, собранных в один удобный контейнер (список). (И опять у нас монада, которая выглядит как контейнер.) Другой способ думать о них как о функциях, возвращающих множество значений, то есть, такие функции возвращают кучу разных значений "в одном". (Я не имею в виду "параллельно", потому что это подразумевает параллельную обработку, чего здесь нет.) Множественные выходные значения - это просто элементы списка. При использовании функций наподобие следующих открываются полезные перспективы:

f :: Int -> [Int]
g :: Int -> [Int]

Здесь и |f|, и |g| принимают одно |Int|-значение и возвращают много |Int|-значений. А что если мы хотим взять каждый результат функции |f| и применить его к каждому результату функции |g|, коллекционируя результаты применения? Было бы здорово, если бы это можно было сделать непосредственно, без распаковки каждого элемента из списков-результатов функций |g| и |f|. И это можно сделать с помощью монады списка.

Давайте перейдем к более материальным примерам этих функций:

f :: Int -> [Int]
f x = [x-1, x, x+1]

g :: Int -> [Int]
g x = [-x, x]

Как же нам "скомпоновать" эти две функции? |f x| возвращает список, и для применения |g| к каждому элементу нам нужна функция |map|:

f 10   -->  [9, 10, 11]
map g (f 10)  -->  [[-9, 9], [-10, 10], [-11, 11]]


