Haskell в реальном мире

В этом блоге уже много написано о самом языке <font color=blue>Haskell</font>, и было несколько статей о его практическом применении. Сейчас я вдохновенно расскажу еще об одном реальном применении языка в производстве.
<habracut />
<h4>Описание данных</h4>
Я работаю в телекомах: фиксированная телефонная связь, интернет, IP-телефония. В задачи входит обработка трафика с АТС, с серверов IP-телефонии, поддержка текущего биллинга, написание софта и администрирование сетей, домена (да, "программист на все руки"). Недавно в моей организации было установлено новое оборудование, работающее совсем по другим принципам, и трафик, соответственно, тоже изменился. Теперь он поставляется в двух вариантах: со старых станций и с новых. Новый трафик дублируется бинарном и текстовом форматах. Бинарники нам вообще не подходят (хотя кое-кто по незнанию говорил: "А чего там? Берешь их, и они сами в биллинг заскакивают!"), текстовый же занимает на порядок больше места, но именно с ним можно что-то сделать. Трафик со старого оборудования все еще идет, и его мы с напарником забрасываем с помощью отработанных схем, использующих сервисы местной СУБД. Можно было бы настроить эти же сервисы для трафика с новых станций, но обнаружилось несколько особенностей. Трафик на новых станциях пишется в отдельные файлы каждые 15 минут; всего таких файлов в сутки получается около 3000 (в идеале - 2976 за 31 день и 2880 за 30 дней). Каждый файл отдельно импортировать не будешь, ибо маразм. Слить в один их можно и даже нужно, благо они все текстовые, и записи о звонках расположены построчно. Ручное слияние выглядит так: выделяешь файлы только за прошлый месяц и добавляешь их в простейший скрипт слияния в командной строке. Формат имени файла фиксирован, следовательно, слияние можно автоматизировать, только придется парсить год и месяц. Линуксоиды бы использовали какой-нибудь <font color=blue>Bash</font>, <font color=blue>Perl</font> или <font color=blue>Python</font>, - дешево и сердито, но на Windows-машину их ради одной операции не поставишь, то же самое касается и <font color=blue>PowerShell</font>. А <font color=blue>cmd</font> - это извращение, о чем мы с вами хорошо знаем. ;) Наконец, в самом трафике тоже обнаружились сюрпризы, из-за которых даже после слияния и импорта с помощью средств СУБД требовалось много ручной SQL-работы. В общем, факторы как-то так удачно сложились в задачу для <font color=blue>Haskell</font>, который я в то время (апрель-май 2011) начал изучать.

Итак, ~ 3000 15-тиминутных файлов за месяц. На оборудовании можно изменить интервал и поставить не 15 минут, а любое другое значение: 5, 10, 30, 45... Количество файлов и их размеры, соответственно, изменятся. Пример имени файла (за 09.05.2011 09:30:00):

<blockquote><pre>999992011050909300081.txt
99999                      - идентификатор, вшитый в оборудование (по понятным причинам, я его заменил на девятки)
     2011                  - год
         05                - месяц
           09              - день
             09            - часы
               30          - минуты
                 00        - секунды
                   81      - какое-то случайное число, возможно, десятые доли секунд.</pre></blockquote>

Абонентов становится больше, и каждый файл уверенно растет в размере. Сейчас у нас в среднем 240 строчек на файл, но было сезонное летнее проседание, люди разъехались по отпускам и звонили меньше. За сентябрь ждем увеличения активности в полтора-два раза.

Записи о звонках разнообразны. Есть несколько разных типов записей, у которых разное количество полей. Записи типа R210 попадаются очень редко, и что они значат, мы не стали выяснять (здесь и далее данные трафика заменены случайными):

<blockquote><pre>|R210|2011-06-24 21:43:53|2011-06-24 01:43:52|1|</pre></blockquote>

Как нетрудно убедиться, здесь всего лишь 4 поля: идентификатор типа записи, дата начала, дата конца (формат ISO 8601/SQL) и, зачем-то, единичка. Поля разделяются вертикальной чертой, которая должна стоять и в начале записи, и в конце, так что реально полей на 1 больше, то есть, 5. Удобно считать, что поле с индексом 0 пустое, находится перед первой вертикальной чертой. Тогда отсчет значимых полей будет идти с 1.

Обычные звонки регистрируются в записях типа R200. Там уже 152 поля, причем это можно перенастроить на оборудовании: какие-то поля добавить, какие-то удалить, а у прочих, возможно, поменять формат.

<blockquote><pre>|R200|99999|111111|CR,CS,AM|1|1|3022|222222|333333|||2011-06-23 11:33:58|C|2011-06-23 11:34:22|S|0|16|1||||||1|1||||||3|162|17|1|12|24|||||||||||16|0||||||192.168.1.172||192.168.1.12||||||8|8|20|20|64|64|20|0|0|OS|7777|8888|555555|666666|0|8|9||||OS|19|||30|10|42|43||||||||||||1||||||1|1|0|3||222222|||||||2|1||333333|||||||||||||||||||||||||||||||</pre></blockquote>

Нас интересуют поля с индексами <font color=blue>[7, 8, 9, 12, 14, 36, 112, 122]</font>, и в конечном результате хотелось бы отфильтровать всё ненужное, чтобы лишнего в СУБД не импортировать. Выбрав из сырых данных только нужное, получим строку:

<blockquote><pre>Запись:   3022|222222|333333|2011-06-23 11:33:58|2011-06-23 11:34:22|24|222222|333333
Индексы:  7   |8     |9     |12                 |14                 |36|112   |122

Индексы |  Объяснение
---------------------------
7       |  код города Читы
8, 112  |  исходящий номер
9, 122  |  входящий номер
12      |  дата и время начала разговора
14      |  дата и время конца разговора
36      |  длительность разговора в секундах</pre></blockquote>

Все остальные поля особо не нужны. Некоторые, как вы видите, вообще пустые, а смысл прочих - неизвестен. Разве что IP-адреса (изменены) принадлежат двум платам в инфраструктуре телефонной сети, между которыми пойдет RTP-трафик. Импортировав эти поля, можно было бы изучить нагрузку на платы. Возможно, в будущем пригодится.

Записи в трафике идут плотно, строка за строкой. Возможно, есть какие-то другие типы записей, но они нам не интересны. Для тарификации достаточно только записей типа R200. Однако, во время визуального исследования трафика выяснилось еще одно интересное обстоятельство. Иногда попадались звонки с одного номера, начавшиеся в одно и то же время, но длительность их была разная. Сначала, в условиях неполной информации я подумал, что это какой-то глюк, ведь не может же человек звонить параллельно с одного и того же номера. Потом стала просматриваться закономерность, и, наконец, я понял, в чем дело. Вот пример таких записей на один номер телефона, все лишние поля я для наглядности выбросил:

<blockquote><pre>|7   |8     |9     |12                 |14                 |36  |
|3022|222222|333333|2011-05-23 13:07:54|2011-05-23 13:37:54|1800|
|3022|222222|333333|2011-05-23 13:07:54|2011-05-23 13:59:40|3106|

|3022|444444|555555|2011-05-23 14:53:52|2011-05-23 15:23:52|1800|
|3022|444444|555555|2011-05-23 14:53:52|2011-05-23 15:53:52|3600|
|3022|444444|555555|2011-05-23 14:53:52|2011-05-23 16:00:50|4018|

|3022|666666|777777|2011-05-23 19:15:55|2011-05-23 19:45:54|1800|
|3022|666666|777777|2011-05-23 19:15:55|2011-05-23 20:15:54|3600|
|3022|666666|777777|2011-05-23 19:15:55|2011-05-23 20:45:54|5400|
|3022|666666|777777|2011-05-23 19:15:55|2011-05-23 20:47:17|5483|</pre></blockquote>

Вам-то сейчас видно, в чем соль, а тогда мне эти записи среди тысяч им подобных, среди кучи лишних полей, букв и цифр, найти было нелегко. В общем, это было или везение, или интуиция, или волшебство. :) А разгадка проста: оборудование каждые полчаса (1800 секунд) отмечает "веху разговора" на случай, если что-то произойдет. Даже если последние 29 минут разговора были почему-то утеряны, весь предыдущий трехчасовой дискурс был многажды зафиксирован - для пущей надежности. В последней записи будут актуальные данные. Возможно, на оборудовании длительность вех можно как-то изменить, а пока их ряд выглядит так: <font color=blue>[1800, 3600, 5400, 7200, 9000, 10800..]</font> Здесь еще примечательно то, что запись-веха отличается в нескольких "неважных" полях от записи-результата. Возможно, стоит учесть это в будущем, чтобы более качественно отфильтровывать ненужное, а пока я принял решение все записи с длительностью из этого ряда просто выбрасывать. Теоретически, здесь какой-то малый процент нормальных звонков будет утерян, но для этого нужно, чтобы человек разговаривал полчаса в точности до секунды. Вероятность этого очень-очень маленькая, а объемы у нас не такие значительные, чтобы закон больших чисел как-то повлиял на выборку. Мы назвали это явление творчески: "Проблема 1800 секунд".

<h4>Кратко о программах</h4>
Всего я создал четыре программы, которые сливали нужные файлы и отфильтровывали полезную информацию. Первоначально это были parser и merger - две программы, написанные по отдельности и соединенные в третью, тоже названную merger. Все они работали крайне медленно и потребляли много памяти, хотя с задачами справлялись. Данные одного месяца (3000 файлов по 240 строк = 720000 строк) они могли обрабатывать, минимум, 10 минут с отжиранием 500 мб памяти (а то и больше, ведь работал своп). Очень, очень страшный результат. И хотя задачу надо было выполнять 1 раз в месяц, мой напарник презрительно морщил нос на <font color=blue>Haskell</font>. Правда, <font color=blue>Haskell</font> тут ну совершенно ни при чем; это я допустил в программах ряд типичных ошибок начинающего функциональщика, из-за чего кривые алгоритмы работали из рук вон плохо. Но работали! Даже больше: программы (а самая большая из них занимает всего лишь 150 полезных строк) можно было настроить из командной строки. Вот какие функции были доступны:

1. Работа в режиме без параметров. Поля берутся по умолчанию, берутся файлы прошлого месяца.
2. Работа в режиме с параметрами:
- Fields [<список индексов полей>] - какие поля взять (parser Fields [1, 24, 55]);
- (yyyy, mm) - какой месяц обрабатывать (merger (2011, 5));
-W - не закрывать консольное окно после отработки (от слова "wait").
3. Получались три файла:
- yyyy.mm.txt - в него сливались все файлы с сырым трафиком за этот месяц;
- processed.txt - файл только с нужными полями за этот месяц;
- yyyy.mm.txt.log - файл-лог, где перечисляются задействованные сырые файлы и пишется сводная информация (количество строк, файлов, диапазон дат).
4. Программы выводят на экран статистику и примеры обработанного трафика.

Пару-тройку раз мы пользовались, чем было, но потом я, конечно, переписал программу с нуля. Уж очень в старом коде было много кривого кода, ненужных велосипедов, глупых алгоритмов и странных решений. В итоге четвертая программа, NgnParser, при той же функциональности и на том же наборе данных работает не 10 минут, а 10 секунд, потребляя всего лишь 10 мб памяти. По скорости разница составляет почти два порядка и, как минимум, один - по памяти! Что можно было такого намутить, чтобы <i>так</i> замедлить программу? Полагаю, есть люди, наступившие на те же грабли, что и я, которые поверили скорее в тормознутость языка, чем в свои кривые руки, - недаром в Интернете так много воплей по поводу и без повода... <font color=blue>Haskell</font> - замечательный язык. Мне было легко писать эти программы. На каждую я тратил не более двух рабочих дней. И всякий раз получал море удовольствия. Не представляю, сколько было бы мучений, если бы то же самое я делал на <font color=blue>C</font>.

<h4>Первая программа</h4>
Первую программу я начал с простого. Покамест я сливал нужные файлы в один (merged.txt) средствами командной строки, а задача parser'а была в парсинге трафика и отфильтровывании нужных записей с идентификатором R200. Для обработки большого количества текста целесообразнее использовать специальный тип строки <font color=blue>ByteString</font>. Но работать с ним не так удобно, как с обычным типом <font color=blue>String</font>. Если <font color=blue>ByteString</font> - это оптимизированная реализация строки как таковой, то <font color=blue>String</font> - это список символов, то есть, <font color=blue>[Char]</font>. <font color=blue>String</font>, благодаря своей природе, очень удобен, но на больших данных производительность любых списков резко падает. В первых версиях программы именно <font color=blue>String</font> и несколько глупых решений стали причиной сильных тормозов и большого пожирания памяти. Однако, меня тогда волновала скорость разработки, а не производительность. Прототип программы я написал очень быстро. Вот как он выглядит (ревизия 2):

<blockquote>replaceChars&nbsp;<font color="#66cc66"><b>::</b></font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char">Char</a></font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char">Char</a></font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char">Char</a></font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Char">Char</a></font><br/>
replaceChars&nbsp;whatC&nbsp;withC&nbsp;c&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font color="#06c">if</font>&nbsp;c&nbsp;<font color="#339933">==</font>&nbsp;whatC&nbsp;<font color="#06c">then</font>&nbsp;withC&nbsp;<font color="#06c">else</font>&nbsp;c<br/>
&nbsp;<br/>
interestFields&nbsp;<font color="#66cc66"><b>::</b></font>&nbsp;<font>&#91;</font><font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String">String</a></font><font>&#93;</font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font>&#91;</font><font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int">Int</a></font><font>&#93;</font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font>&#91;</font><font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String">String</a></font><font>&#93;</font><br/>
interestFields&nbsp;s&nbsp;takeWhat&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>undefined</font>&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5d478b">--&nbsp;Заглушка</font><br/>
&nbsp;<br/>
isR200&nbsp;<font color="#66cc66"><b>::</b></font>&nbsp;<font>&#91;</font><font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String">String</a></font><font>&#93;</font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool">Bool</a></font><br/>
isR200&nbsp;s&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>&#40;</font><font>head</font>&nbsp;s<font>&#41;</font>&nbsp;<font color="#339933">==</font>&nbsp;<font>&quot;R200&quot;</font><br/>
&nbsp;<br/>
processLine&nbsp;<font color="#66cc66"><b>::</b></font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String">String</a></font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String">String</a></font><br/>
processLine&nbsp;s&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font color="#06c">if</font>&nbsp;isR200&nbsp;sInWords&nbsp;<font color="#06c">then</font>&nbsp;<font>unwords</font>&nbsp;<font>&#40;</font>interestFields&nbsp;sInWords&nbsp;<font>&#91;</font><font color=red>1</font><font color="#339933">,</font><font color=red>2</font><font color="#339933">,</font><font color=red>3</font><font>&#93;</font>&nbsp;<font>&#41;</font>&nbsp;<font color="#06c">else</font>&nbsp;<font>&#91;</font><font>&#93;</font>&nbsp;&nbsp;<font color="#5d478b">--&nbsp;[1,2,3]&nbsp;-&nbsp;тестовые&nbsp;поля</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#06c">where</font>&nbsp;sInWords&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>words</font>&nbsp;<font>&#40;</font>&nbsp;<font>map</font>&nbsp;<font>&#40;</font>replaceChars&nbsp;'<font color="#339933">|</font>'&nbsp;'&nbsp;'<font>&#41;</font>&nbsp;s&nbsp;<font>&#41;</font><br/>
&nbsp;<br/>
processString&nbsp;<font color="#66cc66"><b>::</b></font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String">String</a></font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font>&#91;</font><font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String">String</a></font><font>&#93;</font><br/>
processString&nbsp;s&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>map</font>&nbsp;processLine&nbsp;<font>&#40;</font><font>lines</font>&nbsp;<font color="#339933">$</font>&nbsp;s<font>&#41;</font><br/>
&nbsp;<br/>
main&nbsp;<font color="#66cc66"><b>::</b></font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:IO">IO</a></font>&nbsp;<font>&#40;</font><font>&#41;</font><br/>
main&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font color="#06c">do</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;str&nbsp;<font color="#339933">&lt;-</font>&nbsp;<font>readFile</font>&nbsp;<font>&quot;merged.txt&quot;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font>putStrLn</font>&nbsp;<font>&#40;</font>intercalate&nbsp;<font>&quot;<font>\r</font><font>\n</font>&quot;</font>&nbsp;<font>&#40;</font>processString&nbsp;<font color="#339933">$</font>&nbsp;str<font>&#41;</font><font>&#41;</font></blockquote>

Сразу можно заметить странную функцию <font color=blue>replaceChars</font> с типом <font color=blue>Char -> Char -> Char -> Char</font>. Идея была такая: берем строку-запись, заменяем вертикальную черту '|' на пробел и используем функцию <font color=blue>words</font> для разбиения строки на слова:

<blockquote>sInWords&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>words</font>&nbsp;<font>&#40;</font>&nbsp;<font>map</font>&nbsp;<font>&#40;</font>replaceChars&nbsp;'<font color="#339933">|</font>'&nbsp;'&nbsp;'<font>&#41;</font>&nbsp;s&nbsp;<font>&#41;</font></blockquote>

В результате выполнения <font color=blue>sInWords</font> получится следующее преобразование:

<blockquote><font>&quot;|R200|99999|111111|CR,CS,AM|1|1|3022|222222|333333|||2011-06-23&nbsp;11:33:58|&quot;</font>&nbsp;&nbsp;<font color="#339933">--&gt;</font><br/>
<font>&quot;&nbsp;R200&nbsp;99999&nbsp;111111&nbsp;CR,CS,AM&nbsp;1&nbsp;1&nbsp;3022&nbsp;222222&nbsp;333333&nbsp;&nbsp;&nbsp;2011-06-23&nbsp;11:33:58&nbsp;&quot;</font>&nbsp;&nbsp;<font color="#339933">--&gt;</font><br/>
<font>&#91;</font><font>&quot;R200&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;99999&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;111111&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;CR,CS,AM&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;1&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;1&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;3022&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;222222&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;333333&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;2011-06-23&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;11:33:58&quot;</font><font>&#93;</font></blockquote>

К сожалению, поле с датой-временем тоже разобьется на два отдельных поля. Позже, чтобы этого избежать, я еще больше усложнил конструкцию, изначально подменив пробел в этом поле звездочкой и потом его вернув. В итоге строка-запись проходила еще больше преобразований:

Замена ' ' -> '*';
Замена '|' -> ' ';
Разбиение на слова функцией <font color=blue>words</font>;
Обработка списка полей, получение полей с нужным индексом;
Слияние полей функцией <font color=blue>unwords</font>;
Замена ' ' -> '|'
Замена '*' -> ' '

Кроме того, после этих жутких преобразований количество полученных полей не совпадало с количеством исходных, - ведь пустые поля в итоге вообще исчезали (см. пример преобразования выше). Хорошо, что во всех записях пустые/заполненные поля были на одних и тех же местах, а не то б я получил неприятные артефакты. Код, как вы видите, не только избыточный, но и некрасивый. Я даже не берусь оценить его асимптотическую сложность; думаю, она далеко превысила O(n^2). Более того, ближе к ревизии 12 я понял, что надо что-то делать с полями, которые теряются из-за двойных вертикальных черт. И добавил еще одно преобразование:

<blockquote><font color="#5d478b">--&nbsp;Чтобы&nbsp;пустые&nbsp;поля,&nbsp;обозначенные&nbsp;как&nbsp;&quot;||&quot;,&nbsp;обрабатывались&nbsp;корректно,&nbsp;между&nbsp;ними&nbsp;вставляется&nbsp;пробел.</font><br/>
refieldDoubles&nbsp;<font color="#66cc66"><b>::</b></font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String">String</a></font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String">String</a></font><br/>
refieldDoubles&nbsp;<font>&#91;</font><font>&#93;</font>&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>&#91;</font><font>&#93;</font><br/>
refieldDoubles&nbsp;<font>&#40;</font>'<font color="#339933">|</font>':<font>&#91;</font><font>&#93;</font><font>&#41;</font>&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>&quot;|&quot;</font><br/>
refieldDoubles&nbsp;<font>&#40;</font>'<font color="#339933">|</font>':'<font color="#339933">|</font>':ss<font>&#41;</font>&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>&quot;|&nbsp;|&quot;</font>&nbsp;<font color="#339933">++</font>&nbsp;<font>&#40;</font>refieldDoubles&nbsp;<font>&#40;</font>'<font color="#339933">|</font>':ss<font>&#41;</font><font>&#41;</font><br/>
refieldDoubles&nbsp;<font>&#40;</font>s:<font>&#91;</font><font>&#93;</font><font>&#41;</font>&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>&#91;</font>s<font>&#93;</font><br/>
refieldDoubles&nbsp;<font>&#40;</font>s:ss<font>&#41;</font>&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;s&nbsp;:&nbsp;<font>&#40;</font>refieldDoubles&nbsp;ss<font>&#41;</font></blockquote>

Тем самым добавил еще один полный проход по каждой строке! Вот уж во истину - мартышкин труд. А ведь нужно было-то совсем немного: вместо всего этого использовать функцию <font color=blue>split</font> из модуля <font color=blue>Data.String.Utils</font>, или написать свой вариант. Тогда всего лишь за один проход по строке-записи я бы получил правильное разбиение на поля:

<blockquote>split&nbsp;<font>&quot;|&quot;</font>&nbsp;<font>&quot;|R200|99999|111111|CR,CS,AM|1|1|3022|222222|333333|||2011-06-23&nbsp;11:33:58|&quot;</font>&nbsp;<font color="#339933">-&gt;</font><br/>
<font>&#91;</font><font>&quot;&quot;</font><font color="#339933">,</font><font>&quot;R200&quot;</font><font color="#339933">,</font><font>&quot;99999&quot;</font><font color="#339933">,</font><font>&quot;111111&quot;</font><font color="#339933">,</font><font>&quot;CR,CS,AM&quot;</font><font color="#339933">,</font><font>&quot;1&quot;</font><font color="#339933">,</font><font>&quot;1&quot;</font><font color="#339933">,</font><font>&quot;3022&quot;</font><font color="#339933">,</font><font>&quot;222222&quot;</font><font color="#339933">,</font><font>&quot;333333&quot;</font><font color="#339933">,</font><font>&quot;&quot;</font><font color="#339933">,</font><font>&quot;&quot;</font><font color="#339933">,</font><font>&quot;2011-06-23&nbsp;11:33:58&quot;</font><font color="#339933">,</font><font>&quot;&quot;</font><font>&#93;</font></blockquote>
Что сказать... <s>facepalm</s> Слов нет, одни эмоции.

<h4>Какие возможны улучшения</h4>
Опытные хаскеллисты уже заметили, что в коде не используется бесточечный стиль (я его еще не прочувствовал на тот момент), и case-конструкций, сопоставления с образцом или там каких-нибудь охранных выражений почти нет. В итоге даже такой простой код читать местами тяжело. Вот как лучше было бы записать несколько функций:

<blockquote>replaceSymbols&nbsp;s&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>map</font>&nbsp;<font>&#40;</font>replaceChar&nbsp;'<font color="#339933">|</font>'&nbsp;'&nbsp;'<font>&#41;</font>&nbsp;<font>&#40;</font><font>map</font>&nbsp;<font>&#40;</font>replaceChar&nbsp;'&nbsp;'&nbsp;'<font color="#339933">*</font>'<font>&#41;</font>&nbsp;s<font>&#41;</font><br/>
<font color="#5d478b">--&nbsp;--&gt;</font><br/>
replaceSymbols&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>map</font>&nbsp;<font>&#40;</font>replaceChar&nbsp;'<font color="#339933">|</font>'&nbsp;'&nbsp;'&nbsp;<font color="#339933">.</font>&nbsp;replaceChar&nbsp;'&nbsp;'&nbsp;'<font color="#339933">*</font>'<font>&#41;</font><br/>
&nbsp;<br/>
&nbsp;<br/>
isR200&nbsp;s&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>&#40;</font><font>head</font>&nbsp;s<font>&#41;</font>&nbsp;<font color="#339933">==</font>&nbsp;<font>&quot;R200&quot;</font><br/>
<font color="#5d478b">--&nbsp;--&gt;</font><br/>
isR200&nbsp;<font>&#40;</font><font>&quot;R200&quot;</font>:<font color="#339933">_</font><font>&#41;</font>&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;True<br/>
isR200&nbsp;<font color="#339933">_</font>&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;False<br/>
&nbsp;<br/>
&nbsp;<br/>
replaceChars&nbsp;whatC&nbsp;withC&nbsp;c&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font color="#06c">if</font>&nbsp;c&nbsp;<font color="#339933">==</font>&nbsp;whatC&nbsp;<font color="#06c">then</font>&nbsp;withC&nbsp;<font color="#06c">else</font>&nbsp;c<br/>
<font color="#5d478b">--&nbsp;--&gt;</font><br/>
replaceChars&nbsp;whatC&nbsp;withC&nbsp;c&nbsp;<font color="#339933">|</font>&nbsp;c&nbsp;<font color="#339933">==</font>&nbsp;whatC&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;withC<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">|</font>&nbsp;<font><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:otherwise">otherwise</a></font>&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;c<br/>
&nbsp;<br/>
&nbsp;<br/>
processLine&nbsp;s&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font color="#06c">if</font>&nbsp;isR200&nbsp;sInWords&nbsp;<font color="#06c">then</font>&nbsp;<font>unwords</font>&nbsp;<font>&#40;</font>interestFields&nbsp;sInWords&nbsp;<font>&#91;</font><font color=red>1</font><font color="#339933">,</font><font color=red>2</font><font color="#339933">,</font><font color=red>3</font><font>&#93;</font>&nbsp;<font>&#41;</font>&nbsp;<font color="#06c">else</font>&nbsp;<font>&#91;</font><font>&#93;</font><br/>
                <font color="#06c">where</font>&nbsp;sInWords&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>words</font>&nbsp;<font>&#40;</font>&nbsp;<font>map</font>&nbsp;<font>&#40;</font>replaceChars&nbsp;'<font color="#339933">|</font>'&nbsp;'&nbsp;'<font>&#41;</font>&nbsp;s&nbsp;<font>&#41;</font><br/>
<font color="#5d478b">--&nbsp;--&gt;</font><br/>
processLine&nbsp;s&nbsp;<font color="#339933">|</font>&nbsp;isR200&nbsp;sInWords&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>unwords</font>&nbsp;<font>&#40;</font>interestFields&nbsp;sInWords&nbsp;<font>&#91;</font><font color=red>1</font><font color="#339933">,</font><font color=red>2</font><font color="#339933">,</font><font color=red>3</font><font>&#93;</font>&nbsp;<font>&#41;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">|</font>&nbsp;<font><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:otherwise">otherwise</a></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>&#91;</font><font>&#93;</font><br/>
    <font color="#06c">where</font>&nbsp;sInWords&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>words</font>&nbsp;<font color="#339933">.</font>&nbsp;<font>map</font>&nbsp;<font>&#40;</font>replaceChars&nbsp;'<font color="#339933">|</font>'&nbsp;'&nbsp;'<font>&#41;</font>&nbsp;<font color="#339933">$</font>&nbsp;s<br/>
&nbsp;<br/>
&nbsp;<br/>
processString&nbsp;s&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>map</font>&nbsp;processLine&nbsp;<font>&#40;</font><font>lines</font>&nbsp;<font color="#339933">$</font>&nbsp;s<font>&#41;</font><br/>
<font color="#5d478b">--&nbsp;--&gt;</font><br/>
processString&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>map</font>&nbsp;processLine&nbsp;<font color="#339933">.</font>&nbsp;<font>lines</font></blockquote>

Функцию <font color=blue>intercalate "\r\n"</font> вообще нужно было заменить на <font color=blue>unlines</font>. Было бы и короче, и понятнее, да и в тестах <font color=blue>unlines</font> показал большую производительность - не менее 30%:

<blockquote><pre>ItemsCnt  testUnlines(ns)   testIntercalate(ns)    Percent
10        23.84             34.05                  29.9
100       22.70             34.62                  34.4
1000      23.28             35.48                  34.3
10000     22.17             35.48                  37.5
50000     22.13             33.26                  33.4
100000    21.06             35.47                  40.6
200000    22.70             34.05                  33.3</pre></blockquote>

Но будучи еще неопытным, я плохо знал стандартные функции даже из модуля <font color=blue>Prelude</font>, из-за чего городил ненужные велосипеды. Хотя, я даже сейчас не очень понимаю, как можно минимальными усилиями выбрать элементы с нужными индексами из списка элементов. Сравним код из старой и новой программы:

<blockquote><font color="#5d478b">--&nbsp;Старый&nbsp;код:</font><br/>
<font color="#5d478b">--&nbsp;Аргумент&nbsp;1&nbsp;-&nbsp;список&nbsp;сырых&nbsp;поелй</font><br/>
<font color="#5d478b">--&nbsp;Аргумент&nbsp;2&nbsp;-&nbsp;список&nbsp;нужных&nbsp;индексов</font><br/>
takeInterest&nbsp;<font color="#66cc66"><b>::</b></font>&nbsp;<font>&#91;</font><font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String">String</a></font><font>&#93;</font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font>&#91;</font><font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int">Int</a></font><font>&#93;</font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font>&#91;</font><font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String">String</a></font><font>&#93;</font><br/>
takeInterest&nbsp;<font color="#339933">_</font>&nbsp;<font>&#91;</font><font>&#93;</font>&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>&#91;</font><font>&#93;</font><br/>
takeInterest&nbsp;ss&nbsp;<font>&#40;</font>n:ns<font>&#41;</font>&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>&#91;</font>ss&nbsp;<font color="#339933">!!</font>&nbsp;n<font>&#93;</font>&nbsp;<font color="#339933">++</font>&nbsp;takeInterest&nbsp;ss&nbsp;ns<br/>
&nbsp;<br/>
<font color="#5d478b">--&nbsp;Новый&nbsp;код:</font><br/>
<font color="#5d478b">--&nbsp;Аргумент&nbsp;1&nbsp;-&nbsp;аккумулятор</font><br/>
<font color="#5d478b">--&nbsp;Аргумент&nbsp;2&nbsp;-&nbsp;список&nbsp;нужных&nbsp;индексов</font><br/>
<font color="#5d478b">--&nbsp;Аргумент&nbsp;3&nbsp;-&nbsp;список&nbsp;сырых&nbsp;полей</font><br/>
collectFields&nbsp;<font color="#66cc66"><b>::</b></font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int">Int</a></font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font>&#91;</font><font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int">Int</a></font><font>&#93;</font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font>&#91;</font><font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String">String</a></font><font>&#93;</font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font>&#91;</font><font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String">String</a></font><font>&#93;</font><br/>
collectFields&nbsp;<font color="#339933">_</font>&nbsp;<font color="#339933">_</font>&nbsp;<font>&#91;</font><font>&#93;</font>&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>&#91;</font><font>&#93;</font><br/>
collectFields&nbsp;idx&nbsp;fis&nbsp;<font>&#40;</font>s:ss<font>&#41;</font>&nbsp;<font color="#339933">|</font>&nbsp;idx&nbsp;`<font>elem</font>`&nbsp;fis&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;s&nbsp;:&nbsp;collectFields&nbsp;<font>&#40;</font>idx<font color="#339933">+</font><font color=red>1</font><font>&#41;</font>&nbsp;fis&nbsp;ss<br/>
collectFields&nbsp;idx&nbsp;fis&nbsp;<font>&#40;</font>s:ss<font>&#41;</font>&nbsp;<font color="#339933">|</font>&nbsp;<font><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:otherwise">otherwise</a></font>&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;collectFields&nbsp;<font>&#40;</font>idx<font color="#339933">+</font><font color=red>1</font><font>&#41;</font>&nbsp;fis&nbsp;ss</blockquote>

В первом случае мы итерируем список индексов и вытаскиваем элемент с помощью небезопасной функции <font color=blue>!!</font>. Во втором случае используем аккумулятор одновременно с итерацией по списку полей, и если аккумулятор нашелся в списке индексов, берем текущее поле с индексом аккумулятора в коллекцию. И там, и там - хвостовая рекурсия. Хотя, по тестам, новый код оказался на 40% медленнее. Возможно, в данном случае стоит вернуть старый код, - еще больше ускорить новую программу.

<blockquote><pre>ItemsCnt    takeInterest(ns)  collectFields(ns)  Percent
10          17.33             36.84              52.9
100         20.58             36.84              44.1
1000        21.67             37.92              42.8
10000       21.13             36.84              42.6
50000       21.67             37.92              42.8</pre></blockquote>

<h4>Идем дальше</h4>
Следующая программа - merger - должна была соединять все текстовые файлы за прошлый месяц в один. (Не хотелось каждый раз делать это вручную, а лень, как известно, движитель прогресса.) Возник вопрос: откуда узнать, какой у нас будет прошлый месяц? Да, в общем-то, это просто: берем текущую дату и отнимаем один месяц. Программа должна была использоваться исключительно в первых числах месяца, так что тут проблем не предвиделось. Текущая дата и вообще операции с датой-временем находятся в модуле <font color=blue>Time</font>. Операции со структурой файловой системы лежат в модуле <font color=blue>System.Directory</font>. И те, и другие функции, в основном, работают в монаде <font color=blue>IO</font>, а в то время я еще толком не умел причесывать монадный код, в итоге он выглядит жутко (merger, ревизия 14):

<blockquote>main&nbsp;<font color="#66cc66"><b>::</b></font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:IO">IO</a></font>&nbsp;<font>&#40;</font><font>&#41;</font><br/>
main&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font color="#06c">do</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;args&nbsp;<font color="#339933">&lt;-</font>&nbsp;getArgs<br/>
&nbsp;&nbsp;&nbsp;&nbsp;curDir&nbsp;<font color="#339933">&lt;-</font>&nbsp;getCurrentDirectory<br/>
&nbsp;&nbsp;&nbsp;&nbsp;dirContents&nbsp;<font color="#339933">&lt;-</font>&nbsp;getDirectoryContents&nbsp;curDir<br/>
&nbsp;&nbsp;&nbsp;&nbsp;curTime&nbsp;<font color="#339933">&lt;-</font>&nbsp;T<font color="#339933">.</font>getClockTime<br/>
&nbsp;&nbsp;&nbsp;&nbsp;monthAgoTime&nbsp;<font color="#339933">&lt;-</font>&nbsp;<font>return</font>&nbsp;<font color="#339933">$</font>&nbsp;T<font color="#339933">.</font>addToClockTime&nbsp;<font>&#40;</font>T<font color="#339933">.</font>TimeDiff&nbsp;<font color=red>0</font>&nbsp;<font>&#40;</font><font color="#339933">-</font><font color=red>1</font><font>&#41;</font>&nbsp;<font color=red>0</font>&nbsp;<font color=red>0</font>&nbsp;<font color=red>0</font>&nbsp;<font color=red>0</font>&nbsp;<font color=red>0</font><font>&#41;</font>&nbsp;curTime<br/>
&nbsp;&nbsp;&nbsp;&nbsp;calendarMonthAgoTime&nbsp;<font color="#339933">&lt;-</font>&nbsp;T<font color="#339933">.</font>toCalendarTime&nbsp;monthAgoTime<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#06c">let</font>&nbsp;maybeDateRange&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font color="#06c">case</font>&nbsp;args&nbsp;<font color="#06c">of</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font>&#40;</font>a:b:<font color="#339933">_</font><font>&#41;</font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;readDateRange&nbsp;<font>&#40;</font><font>unwords</font>&nbsp;<font>&#91;</font>a<font color="#339933">,</font>&nbsp;b<font>&#93;</font><font>&#41;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">_</font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;Just&nbsp;<font color="#339933">$</font>&nbsp;defaultDateRange&nbsp;calendarMonthAgoTime<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#06c">case</font>&nbsp;maybeDateRange&nbsp;<font color="#06c">of</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Just&nbsp;dr&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font color="#06c">do</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#06c">let</font>&nbsp;fsToMerge&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;filesToMerge&nbsp;dirContents&nbsp;dr<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#06c">let</font>&nbsp;fsToMergeCountStr&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>show</font>&nbsp;<font color="#339933">$</font>&nbsp;<font>length</font>&nbsp;fsToMerge<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#06c">let</font>&nbsp;mergeLog&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>&#40;</font>newFileName&nbsp;dr&nbsp;<font color="#339933">++</font>&nbsp;<font>&quot;.log&quot;</font><font>&#41;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#06c">let</font>&nbsp;dateRangeMsg&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>&quot;DateRange:&nbsp;&quot;</font>&nbsp;<font color="#339933">++</font>&nbsp;<font>show</font>&nbsp;dr<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fsContents&nbsp;<font color="#339933">&lt;-</font>&nbsp;merge&nbsp;fsToMerge<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font>writeFile</font>&nbsp;<font>&#40;</font>newFileName&nbsp;dr<font>&#41;</font>&nbsp;<font>&#40;</font><font>unlines</font>&nbsp;fsContents<font>&#41;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font>writeFile</font>&nbsp;mergeLog&nbsp;<font>&#40;</font><font>unlines</font>&nbsp;fsToMerge&nbsp;<font color="#339933">++</font>&nbsp;printf&nbsp;<font>&quot;<font>\n</font>%s<font>\n</font>Total&nbsp;files:&nbsp;%s&quot;</font>&nbsp;dateRangeMsg&nbsp;fsToMergeCountStr<font>&#41;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font>putStrLn</font>&nbsp;<font>&#40;</font><font>unlines</font>&nbsp;fsContents<font>&#41;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font>putStrLn</font>&nbsp;dateRangeMsg<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#5d478b">--putStrLn&nbsp;(&quot;Files&nbsp;to&nbsp;merge:&nbsp;&quot;&nbsp;++&nbsp;unlines&nbsp;fsToMerge)</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font>putStrLn</font>&nbsp;<font>&#40;</font>printf&nbsp;<font>&quot;Count&nbsp;of&nbsp;files:&nbsp;%s.&nbsp;See&nbsp;%s&nbsp;for&nbsp;file&nbsp;list.&quot;</font>&nbsp;fsToMergeCountStr&nbsp;mergeLog<font>&#41;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nothing&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font>putStrLn</font>&nbsp;<font>&#40;</font><font>&quot;Invalid&nbsp;date&nbsp;range.&quot;</font><font>&#41;</font></blockquote>

Что этот код делает - даже не рекомендую вникать... Но именно здесь закрался росток будущей огромной ошибки, из-за которой последняя версия старой программы пожирала огромное количество памяти. Рассмотрим функцию <font color=blue>merge</font>, которая вызывается из этого кода:

<blockquote>merge&nbsp;<font color="#66cc66"><b>::</b></font>&nbsp;<font>&#91;</font><font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String">String</a></font><font>&#93;</font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:IO">IO</a></font>&nbsp;<font>&#91;</font><font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String">String</a></font><font>&#93;</font><br/>
merge&nbsp;fsToMerge&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>mapM</font>&nbsp;<font>readFile</font>&nbsp;fsToMerge</blockquote>

Она принимает список файлов, которые надо смержить, читает их и возвращает список их содержимого. В коде есть такие две строчки:

<blockquote><font color="#06c">do</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">...</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;fsContents&nbsp;<font color="#339933">&lt;-</font>&nbsp;merge&nbsp;fsToMerge<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font>writeFile</font>&nbsp;<font>&#40;</font>newFileName&nbsp;dr<font>&#41;</font>&nbsp;<font>&#40;</font><font>unlines</font>&nbsp;fsContents<font>&#41;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">...</font></blockquote>

Ключевой момент - <font color=blue>unlines fsContents</font>. То есть, все сырое содержимое всех файлов соединялось в один присест и запихивалось в файл-результат. В последствии, когда parser и merger были объединены, именно этот огромный объем данных передавался в обработку parser-части, где, вы помните, есть целая куча замен, проходов и прочего оверхеда. Вот как выглядит эта часть кода в старой программе, собранной из parser и merger:

<blockquote><font color="#06c">do</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">...</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;fsContents&nbsp;<font color="#339933">&lt;-</font>&nbsp;readFilesToMerge&nbsp;fsToMerge<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#06c">let</font>&nbsp;mergedContents&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>unlines</font>&nbsp;fsContents<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font>writeFile</font>&nbsp;<font>&#40;</font>newFileName&nbsp;dr<font>&#41;</font>&nbsp;mergedContents<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#06c">let</font>&nbsp;processedContentStr&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>unlines</font>&nbsp;<font color="#339933">$</font>&nbsp;processData&nbsp;nedeedFields&nbsp;mergedContents<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">...</font></blockquote>

И это не просто <s>facepalm</s> плохо, это грубейшее нарушение dataflow-концепции. Должно быть так:

<blockquote><pre>Схема 1
       _____            _____            _____ 
      |     |          |     |          |     |
A1 -> |F(A1)| -> B1 -> |G(B1)| -> C1 -> |H(C1)| -> RESULT 1 -> SAVE
      |_____|          |_____|          |_____|

       _____            _____            _____
      |     |          |     |          |     |
A2 -> |F(A2)| -> B2 -> |G(B2)| -> C2 -> |H(C2)| -> RESULT 2 -> SAVE
      |_____|          |_____|          |_____|

       _____            _____            _____ 
      |     |          |     |          |     |
A3 -> |F(A3)| -> B3 -> |G(B3)| -> C3 -> |H(C3)| -> RESULT 3 -> SAVE
      |_____|          |_____|          |_____|


...->   ...  -> ... ->   ...  ->  ... ->  ...   -> RESULT n -> SAVE</pre></blockquote>

А получилось так:

<blockquote><pre>Схема 2
    ____________________       ____________________       ____________________
   |                    |     |                    |     |                    |
   |                    |     |                    |     |                    |
   |                    |     |                    |     |                    |
A->|        F(A)        |->B->|        G(B)        |->С->|        H(С)        |->RESULT->SAVE
   |                    |     |                    |     |                    |
   |                    |     |                    |     |                    |
   |____________________|     |____________________|     |____________________|</pre></blockquote>


Разницу между последовательной обработкой частей и обработкой всего сразу я прочувствовал в полной мере. Теперь я знаю: не стоит брать весь объем работ сразу, лучше создать механизм, который выдает данные порциями, - так будет и по памяти эффективно, и по скорости лучше. И, кроме всего прочего, программу, сделанную по второй схеме, нельзя распараллелить. Ужас, одним словом...

Позже я пытался соптимизировать старую программу, - заменял почти везде <font color=blue>String</font> на <font color=blue>ByteString</font>. Выигрыш, конечно, был небольшой, но - веером тумана не разгонишь.


Надо ли говорить, что новую программу, NgnTraffic, я делал, имея уже нормальный запас знаний? В ней соблюдено многое. Программа разбита на модули: <font color=blue>Main</font>, <font color=blue>Constants</font>, <font color=blue>DataProcess</font>, <font color=blue>FileListProces</font>, <font color=blue>Options</font>, <font color=blue>Tools</font>, <font color=blue>Types</font>. Используется, конечно, схема 1. Вместо <font color=blue>String</font> изначально взят тип <font color=blue>ByteString</font> (Lazy-вариант). Код более причесан, даже бесточечный стиль в наличии. И, главное, поменялся принцип действия. Сначала собирается список файлов, которые нужно обработать, - эта часть похожа на аналогичную из старой программы. Затем, однако, файлы не читаются все сразу в одну большую переменную, а каждый читается по отдельности. Его содержимое тут же обрабатывается, строки парсятся, записи фильтруются, нужные поля вытаскиваются. Результат дописывается в результирующий файл. В итоге имеем цикл "Чтение с диска (<font color=blue>F(An)</font>) - Обработка строк (<font color=blue>G(Bn)</font>) - Запись результата на диск (<font color=blue>H(Cn)</font>)" - и так много раз по числу файлов. Плюс, конечно, нет никаких замен одного символа на другой, а есть простая функция <font color=blue>split</font> из модуля <font color=blue>Data.ByteString.Char8</font>, которая за один проход разбивает строку-запись на поля и сама по себе выигрывает чудовищную долю производительности. Вот как выглядят функции, удовлетворяющие схеме 1:

<blockquote>process'&nbsp;<font color="#66cc66"><b>::</b></font>&nbsp;ResFilePath&nbsp;<font color="#339933">-&gt;</font>&nbsp;FieldIndexes&nbsp;<font color="#339933">-&gt;</font>&nbsp;FilePath&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:IO">IO</a></font>&nbsp;<font>&#40;</font><font>&#41;</font><br/>
process'&nbsp;resFile&nbsp;fis&nbsp;targetFile&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font color="#06c">do</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fileContents&nbsp;<font color="#339933">&lt;-</font>&nbsp;C<font color="#339933">.</font><font>readFile</font>&nbsp;targetFile<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#06c">let</font>&nbsp;processResult&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;processData&nbsp;fis&nbsp;predicates&nbsp;fileContents<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C<font color="#339933">.</font><font>appendFile</font>&nbsp;resFile&nbsp;processResult<br/>
&nbsp;<br/>
process&nbsp;<font color="#66cc66"><b>::</b></font>&nbsp;ResFilePath&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font>&#91;</font>FilePath<font>&#93;</font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;FieldIndexes&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:IO">IO</a></font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String">String</a></font><br/>
process&nbsp;<font color="#339933">_</font>&nbsp;<font>&#91;</font><font>&#93;</font>&nbsp;<font color="#339933">_</font>&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>return</font>&nbsp;<font>&quot;No&nbsp;files&nbsp;to&nbsp;process.&quot;</font><br/>
process&nbsp;resFile&nbsp;fs&nbsp;fieldIndexes&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font color="#06c">do</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;C<font color="#339933">.</font><font>writeFile</font>&nbsp;resFile&nbsp;C<font color="#339933">.</font>empty<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font>mapM_</font>&nbsp;<font>&#40;</font>process'&nbsp;resFile&nbsp;fieldIndexes<font>&#41;</font>&nbsp;fs<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<font>return</font>&nbsp;<font>&quot;All&nbsp;ok.&quot;</font></blockquote>

Здесь process принимает имя файла-результата, список файлов на обработку и индексы нужных полей. Индексы могут прийти из командной строки, поэтому они выведены как аргумент этой функции. process берет по очереди имя каждого файла и применяет к нему функцию <font color=blue>process'</font> (в строке <font color=blue>mapM_ (process' resFile fieldIndexes) fs</font>). Она уже занимается главной работой с файлами. Функция <font color=blue>processData</font> берет на себя обработку содержимого файла. Интересно то, что помимо фильтрования R200-записей в новой программе создан механизм предикатов: можно любое любую запись проверить по доступному предикату, а сами предикаты нетрудно дополнить нужным. Пока сделано два: поле с индексом x принадлежит списку полей и не принадлежит ему. Так выглядит тип предикатов:

<blockquote><font color="#06c">data</font>&nbsp;Predicate&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;&nbsp;NotInList&nbsp;<font>&#91;</font>C<font color="#339933">.</font>ByteString<font>&#93;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#339933">|</font>&nbsp;InList&nbsp;<font>&#91;</font>C<font color="#339933">.</font>ByteString<font>&#93;</font><br/>
<font color="#06c">type</font>&nbsp;PredicateMap&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>&#91;</font><font>&#40;</font>FieldIndex<font color="#339933">,</font>&nbsp;Predicate<font>&#41;</font><font>&#93;</font></blockquote>

А это заданные предикаты-константы:

<blockquote>predicates&nbsp;<font color="#66cc66"><b>::</b></font>&nbsp;PredicateMap<br/>
predicates&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>&#91;</font><font>&#40;</font><font color=red>1</font><font color="#339933">,</font>&nbsp;&nbsp;InList&nbsp;<font>&#91;</font>C<font color="#339933">.</font>pack&nbsp;<font>&quot;R200&quot;</font><font>&#93;</font><font>&#41;</font><font color="#339933">,</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font>&#40;</font><font color=red>36</font><font color="#339933">,</font>&nbsp;NotInList&nbsp;<font>&#40;</font><font>map</font>&nbsp;C<font color="#339933">.</font>pack&nbsp;<font>&#91;</font><font>&quot;1800&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;3600&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;5400&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;7200&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;9000&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;10800&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;12600&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;14400&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;16200&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;18000&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;19800&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;21600&quot;</font><font color="#339933">,</font>&nbsp;<font>&quot;23400&quot;</font><font>&#93;</font><font>&#41;</font>&nbsp;<font>&#41;</font><font>&#93;</font></blockquote>

Нетрудно догадаться, что предикатам будут удовлетворять только те записи, у которых поле 1 равно "R200", и поле 36 не содержится в списке "Проблемы 1800 секунд". Отсеивание происходит в функциях <font color=blue>checkPredicate</font> и <font color=blue>examineFields</font>:

<blockquote>checkPredicate&nbsp;<font color="#66cc66"><b>::</b></font>&nbsp;Predicate&nbsp;<font color="#339933">-&gt;</font>&nbsp;C<font color="#339933">.</font>ByteString&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool">Bool</a></font><br/>
checkPredicate&nbsp;<font>&#40;</font>NotInList&nbsp;l<font>&#41;</font>&nbsp;str&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>&#40;</font><font>not</font>&nbsp;<font color="#339933">.</font>&nbsp;<font>elem</font>&nbsp;str<font>&#41;</font>&nbsp;l<br/>
checkPredicate&nbsp;<font>&#40;</font>InList&nbsp;l<font>&#41;</font>&nbsp;str&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font>elem</font>&nbsp;str&nbsp;l<br/>
&nbsp;<br/>
examineFields&nbsp;<font color="#66cc66"><b>::</b></font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int">Int</a></font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;PredicateMap&nbsp;<font color="#339933">-&gt;</font>&nbsp;Fields&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font color=green><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool">Bool</a></font><br/>
examineFields&nbsp;<font color="#339933">_</font>&nbsp;<font color="#339933">_</font>&nbsp;<font>&#91;</font><font>&#93;</font>&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;True<br/>
examineFields&nbsp;idx&nbsp;preds&nbsp;<font>&#40;</font>s:ss<font>&#41;</font>&nbsp;<font color="#66cc66"><b>=</b></font>&nbsp;<font color="#06c">case</font>&nbsp;L<font color="#339933">.</font><font>lookup</font>&nbsp;idx&nbsp;preds&nbsp;<font color="#06c">of</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Just&nbsp;<font>pred</font>&nbsp;<font color="#339933">-&gt;</font>&nbsp;<font>&#40;</font>checkPredicate&nbsp;<font>pred</font>&nbsp;s<font>&#41;</font>&nbsp;<font color="#339933">&amp;&amp;</font>&nbsp;<font>&#40;</font>examineFields&nbsp;<font>&#40;</font>idx<font color="#339933">+</font><font color=red>1</font><font>&#41;</font>&nbsp;preds&nbsp;ss<font>&#41;</font><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Nothing&nbsp;<font color="#339933">-&gt;</font>&nbsp;examineFields&nbsp;<font>&#40;</font>idx<font color="#339933">+</font><font color=red>1</font><font>&#41;</font>&nbsp;preds&nbsp;ss</blockquote>

Сейчас я вижу, что функцию <font color=blue>examineFields</font> вполне можно было сделать через <font color=blue>foldr</font>, но это так, мелочи.

В целом, я доволен проделанной работой. Такое бывает редко, - но код NgnTraffic мне даже нравится. А особенно нравится тот прогресс, который стал виден на примере одной и той же программы, написанной в разное время и с разными знаниями. А "еще особеннее" нравится то, что это реальная программа на <font color=blue>Haskell</font>, использующаяся в реальном производстве.

Кто бы что ни говорил, - <font color=blue>Haskell</font> - потрясающий язык, лучший из тех, с которым мне приходилось работать.

Исходники parser по ревизиям: <a href="https://github.com/graninas/<font color=blue>Haskell</font>-Algorithms/blob/master/Materials/<font color=blue>Haskell</font>%20%E2%20%F0%E5%E0%EB%FC%ED%EE%EC%20%EC%E8%F0%E5%20-%20%D1%F2%E0%F2%FC%FF/parser%200.2.hs">[2]</a>, <a href="https://github.com/graninas/<font color=blue>Haskell</font>-Algorithms/blob/master/Materials/<font color=blue>Haskell</font>%20%E2%20%F0%E5%E0%EB%FC%ED%EE%EC%20%EC%E8%F0%E5%20-%20%D1%F2%E0%F2%FC%FF/parser%200.6.hs">[6]</a>, <a href="https://github.com/graninas/<font color=blue>Haskell</font>-Algorithms/blob/master/Materials/<font color=blue>Haskell</font>%20%E2%20%F0%E5%E0%EB%FC%ED%EE%EC%20%EC%E8%F0%E5%20-%20%D1%F2%E0%F2%FC%FF/parser%200.12.hs">[12]</a>
Исходники merger (в том числе и объединенная программа merger): <a href="https://github.com/graninas/<font color=blue>Haskell</font>-Algorithms/blob/master/Materials/<font color=blue>Haskell</font>%20%E2%20%F0%E5%E0%EB%FC%ED%EE%EC%20%EC%E8%F0%E5%20-%20%D1%F2%E0%F2%FC%FF/merger%200.13.hs">[13]</a>, <a href="https://github.com/graninas/<font color=blue>Haskell</font>-Algorithms/blob/master/Materials/<font color=blue>Haskell</font>%20%E2%20%F0%E5%E0%EB%FC%ED%EE%EC%20%EC%E8%F0%E5%20-%20%D1%F2%E0%F2%FC%FF/merger%200.14.hs">[14]</a>, <a href="https://github.com/graninas/<font color=blue>Haskell</font>-Algorithms/blob/master/Materials/<font color=blue>Haskell</font>%20%E2%20%F0%E5%E0%EB%FC%ED%EE%EC%20%EC%E8%F0%E5%20-%20%D1%F2%E0%F2%FC%FF/merger%200.16.hs">[16]</a>, <a href="https://github.com/graninas/<font color=blue>Haskell</font>-Algorithms/blob/master/Materials/<font color=blue>Haskell</font>%20%E2%20%F0%E5%E0%EB%FC%ED%EE%EC%20%EC%E8%F0%E5%20-%20%D1%F2%E0%F2%FC%FF/merger%200.23.hs">[23]</a>
<a href="https://github.com/graninas/<font color=blue>Haskell</font>-Algorithms/tree/master/Programs/NgnTraffic">Исходники NgnTraffic</a>

P.S. Перевод следующей части Yet Another Monad Tutorial тоже скоро будет.