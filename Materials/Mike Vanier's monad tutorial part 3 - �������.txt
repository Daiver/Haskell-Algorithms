Еще Одно Руководство по Монадам (часть 3: Монадные Законы)
Mike Vanier
http://mvanier.livejournal.com

Перевод: Гранин А. С.
graninas@gmail.com

В прошлой статье я рассказал о двух фундаментальных монадических операциях класса типов Monad: оператор связывания (bind, >>=) и функция return. В этой статье я закончу с определением класса типов Monad и расскажу о монадных законах.

Полный класс типов Monad

Давайте взглянем на все определение класса типов Monad:

  class Monad m where
    (>>=) :: m a -> (a -> m b) -> m b
    return :: a -> m a
    (>>) :: m a -> m b -> m b
    fail :: String -> m a

Мы видим знакомое: оператор >>= и функцию return с теми же типами, но кроме них есть еще оператор >> и функция fail. Что они означают?

Функция fail изначально - очень примитивная функция оповещения об ошибке. Она вызывается, когда оператор >>= не может связать значение типа a и функцию типа a -> m b из-за ошибок сопоставления. Я сейчас не хочу вдаваться в детали этого механизма, потому что это скучно; посмотрите документацию на сайте Haskell (http://www.haskell.org/ghc/docs/latest/html/libraries/index.html), если вам это нужно. В большинстве случаев вам не будет нужно беспокоиться о fail.

Оператор >> немного интереснее. У него такой тип:

(>>) :: m a -> m b -> m b

Этот оператор представляет собой монадический оператор последовательности. В частности, это вариант монадического применения (>>= или "bind"), который отбрасывает распакованное значение типа a перед выполнением "действия" типа m b. Он определен следующим образом:

mv1 >> mv2  =  mv1 >>= (\_ -> mv2)

Мы можем видеть здесь, что любое значение, распакованное из монадического значения mv1, отвергается, и потом возвращается финальное монадическое значение mv2. Оператор бывает полезным, когда тип распакованного значения равен (), то есть, пустой тип. Хорошим примером можно считать функцию putStrLn:

putStrLn :: String -> IO ()

Представьте, что вы хотите напечатать две строки, одну за другой, со знаками конца строки после каждой. Можно так:

putStrLn "This is string 1." >> putStrLn "This is string 2."

И почему же это работает? Посмотрим на типы:

(putStrLn "This is string 1.") :: IO ()
(putStrLn "This is string 2.") :: IO ()

То есть, оператор >> комбинирует два монадических значения типа IO () в одно результирующее монадическое значение типа IO (). Давайте возьмем оператор >> и специализируем его для нашего случая:

(>>) :: m a -> m b -> m b

Если m - это IO, и a, и b - (), то получим:

(>>) :: IO () -> IO () -> IO ()

По записи можно сказать, что, вероятно, оператор >> выполняет два "действия" печатания строки, одну за другой.

Теперь более сложный пример. Нам нужно считать строку текста с терминала и дважды ее напечатать. Мы можем сделать это так:

readAndPrintLineTwice :: IO ()
readAndPrintLineTwice = getLine >>= (\s -> (putStrLn s >> putStrLn s))

Из-за приоритетов операторов запись можно оставить без скобок:

readAndPrintLineTwice :: IO ()
readAndPrintLineTwice = getLine >>= \s -> putStrLn s >> putStrLn s

Итак, что это значит? getLine - монадическое значение ("действие"), которое считывает строку текста с терминала. Оператор >>= "распаковывает" эту строку из монадического значения и связывает ее с именем s (потому что |\s -> putStrLn s >> putStrLn s| - это монадическая функция, второй аргумент оператора >>=). Затем строка, названная s, используется монадическим значением putStrLn s >> putStrLn s, которое ее последовательно печатает два раза.

Если вам сказанное кажется мистикой, это не ваша вина. Кое-что странное происходит здесь, в глубине, но пока я не рассказал о монаде состояния, я не смогу это объяснить. Но вообще вы теперь должны суметь проследить, _что_ происходит, даже если вы еще не вполне понимаете, _как_ оно происходит.

Прямо сейчас я собираюсь немного вернуться назад и посмотреть на монадные законы. Они играют большую роль в использовании оператора >>= и функции return для каждой конкретной монады. После этого мы обратимся к более практическим материалам.

Три Закона Монадности

Многие важные законы идут в группах по три: три механических закона Ньютона, три закона термодинамики, Три Закона Робототехники Азимова, три Кеплеровских закона планетарного движения, и так далее, и так далее. Монады в этом не отличаются, ну, конечно, за исключением, что "Три Монадных Закона", важнее всего другого. ;-)

Чтобы оператор >>= и функция return были правильными для определенной монады, они должны иметь корректные типы этой монады. Так, например, определения >>= и return для монады Maybe содержат ее тип:

(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
return :: a -> Maybe a

А для монады IO содержат тип IO:

(>>=) :: IO a -> (a -> IO b) -> IO b
return :: a -> IO b

Однако, этого недостаточно. Эти функции/операторы также обязаны удовлетворять трем "монадным законам". Монадные законы на самом деле очень просты; они призваны гарантировать, что монадическая композиция будет работать предсказуемым образом. Сначала я дам вам "приятную" версию монадных законов, а затем покажу (уродливый) способ, как они обычно описываются. (Вы мне скажете спасибо: "приятный" вариант куда легче понять.)

Приятная версия

Вот приятное определение трех монадных законов, выраженных в терминах монадической композиции (вспомните, что оператор (>=>) - это монадический оператор композиции функций):

1. return >=> f       ==    f
2. f >=> return       ==    f
3. (f >=> g) >=> h    ==    f >=> (g >=> h)

О чем эти законы говорят нам?