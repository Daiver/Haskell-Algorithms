Еще Одно Руководство по Монадам (часть 4: Монада Maybe)
Mike Vanier
http://mvanier.livejournal.com

Перевод: Гранин А. С.
graninas@gmail.com

В предыдущих статьях этой серии мы изучали концептуальный базис монад, но обсуждение наше было слишком абстрактным. Теперь, когда вы, я надеюсь, поняли, что монады такое и для чего они нужны, пришло время перейти к детальному рассмотрению специфических монад. Это значит, что мы определим корректные воплощения класса типов Monad для множества различных понятий вычислений, которые мы увидели раньше. Мы используем наши знания, чтобы получить монадическую композицию в каждом конкретном случае через монадическое применение (оператор >>=), и с помощью монадных законов мы выведем определение return.

Монада Maybe

Монаду Maybe обычно первой представляют в руководствах по Haskell, потому что она очень проста в использовании, реализации и понимании. Для начала взглянем на определение типа данных Maybe:

data Maybe a = Nothing | Just a

Здесь указано, что Maybe - это конструктор типа, в который помещается определенный тип |a|, чтобы получить (конкретный) тип данных. Обычно говорят, что Maybe - это "полиморфный" тип данных, смысл тот же. Так, если бы |a| был Int, мы бы получили:

data Maybe Int = Nothing | Just Int

Только вот нам не нужно это писать непосредственно, так как абстрактное определение выше подходит ко всем типам.

Значение типа Maybe a может либо быть, либо отсутствовать. Если значение Nothing ("Ничто"), то его "как бы и нет", а если оно Just x для некоторого значения x, то это "просто" значение x. Можно думать об этом как о контейнере, в котором либо 0 элементов, либо он один. (Вспомните: я когда-то говорил, что монадические значения иногда ошибочно представляются в виде контейнеров. Это тот самый случай.)

Полиморфный тип Maybe полезен тем, что мы можем использовать его как модель "расширенной функции", которая либо производит что-то как выходное значение, либо терпит в этом крах и не может вернуть никакое значение. (То есть, такая функция может провалиться.) Это можно записать так:

f :: a -> Maybe b

Функция f берет значение типа a и либо возвращает Nothing (признак неудачи), либо значение Just x, где у x тип b. Функции вроде f будут работать в монаде Maybe, и композиция двух таких функций выглядит следующим образом:

f :: a -> Maybe b   -- предполагаем, что f где-то определена
g :: b -> Maybe c   -- предполагаем, что g где-то определена

h :: a -> Maybe c   -- монадическая композиция f и g
h = f >=> g         -- вспомним: >=> - это оператор монадической композиции

Мы говорили, что все монады должны быть конструкторами типов. Maybe - это конструктор типа, так что тут все хорошо. Но для того чтобы Maybe стал монадой, нам нужно создать экземпляр класса типов Monad, а это значит, что мы должны заполнить следующее определение:

instance Monad Maybe where
  (>>=)  = {- определение >>= для Maybe -}
  return = {- определение return для Maybe -}

Как мы можем задать (>>=) и return для Maybe?

Сначала напишем каркас определения для >>=, покрывающий два возможных случая левого операнда типа Maybe a:

Nothing >>= f  =  {- нужно дописать -}
Just x  >>= f  =  {- нужно дописать -}

где x имеет тип a. Левую часть определения можно написать и подругому:

(>>=) Nothing  f  =  {- нужно дописать -}
(>>=) (Just x) f  =  {- нужно дописать -}

Но лучше все-таки, если оператор (>>=) задан как оператор, а не как функция, и Haskell нам это позволяет.

Для завершения этого определения подумаем, что мы хотим получить от монадической композиции в монаде Maybe. Давайте возьмем наш пример с функциями f и g, монадически их скомпонуем и получим функцию h:

f :: a -> Maybe b
g :: b -> Maybe c
h :: a -> Maybe c
h = f >=> g

Если мы передадим аргумент в функцию f, и она вернет Nothing (то есть, потерпит неудачу), тогда что должна вернуть функция h?

f x = Nothing
h x = (f >=> g) x = ???

Кажется очевидным, что если f x вернет Nothing, то и h тоже должна вернуть Nothing, поскольку если часть выражения (функция f) не смогла вернуть результат, то и все выражение (функция h) не сможет его вернуть. Единственный вариант, когда h возвращает значение, это когда f вернет результат (назовем его y), он будет передан функции g, и g y тоже вернет результат. Если провалится f или g, то и h тоже завершится неудачей, то есть, вычислением h x будет Nothing.

Имея это в виду, из нашего определения h получим:

h = f >=> g
h = \x -> (f x >>= g)  -- эквивалент (из определения >=>)
h x = f x >>= g        -- эквивалент
-- предположим, что f x == Nothing
h x = (Nothing >>= g)
    = Nothing
-- таким образом:
Nothing >>= g = Nothing

Теперь мы знаем, как оператор (>>=) реагирует на аргумент Nothing, - он просто возвращает тот же Nothing:

Nothing >>= f  =  Nothing
Just x  >>= f  =  {- нужно дописать -}

Обратите внимание, я здесь заменил g на f, и это корректно, ведь имена функций не важны здесь. На практике мы вообще избавляемся от имен функций, если это возможно, и заменяем их специальным оператором _ (нижнее подчеркивание), вот так:

Nothing >>= _  =  Nothing

Со вторым уравнением этого сделать нельзя, потому что функцию f мы еще будем использовать в определении.

Теперь давайте подойдем с другой стороны. Если f x _не_ провалится, результатом будет значение Just y для некоторого y. Нам нужно "распаковать" значение y из Just y, которое мы бы потом передали функции g, и g y - это результат всей функции h:

h = f >=> g
h = \x -> (f x >>= g)  -- эквивалент (из определения >=>)
h x = f x >>= g        -- эквивалент
-- предположим, что f x == Just y 
h x = (Just y >>= g)
    = g y

Что дает нам вторую часть определения:

Nothing >>= f  =  Nothing
Just x  >>= f  =  f x

Заметьте, что я заменил y на x и g на f. Опять же, имена переменных и функций не имеют значения до тех пор, пока вы последовательны.

На этом завершается определение оператора >>= для монады Maybe. Теперь нам нужно получить return для этой монады:

return x  =  ???

для любого значения x. Какие у нас есть варианты? Мы могли бы просто сказать, что

return x  =  Nothing

для любого x. Однако мы бы нарушили монадные законы, если бы так сделали:

return x >>= f  ==  f x
Nothing >>=  f  ==  f x
Nothing         ==  f x   -- НЕВЕРНО!

Предполагая, что по крайней мере _некоторые_ f x не Nothing (например, рассмотрим монадическую функцию f x = Just x), получим ошибку. Есть и другой вариант:

return x  =  Just x

и он удовлетворяет монадным законам:

return x >>= f
  = (Just x) >>= f   -- по определению return для монады Maybe
  = f x              -- по определению >>= для монады Maybe
                     -- выполнение первого монадного закона

Just x >>= return
  = return x         -- по определению >>= для монады Maybe
  = Just x           -- по определению return для монады Maybe
                     -- выполнение второго монадного закона

Nothing >>= return
  = Nothing          -- по определению >>= для монады Maybe
                     -- выполнение второго монадного закона

Раз законы соблюдаются, этот вариант и возьмем. Полное определение монады Maybe выглядит так:

instance Monad Maybe where
  return x  =  Just x

  Nothing >>= f  =  Nothing
  Just x  >>= f  =  f x

Вау! Мы только что создали нашу первую монаду!

Просто чтобы обезопасить себя, проверим, что она удовлетворяет третьему монадному закону, который гласит:

(mv >>= f) >>= g    ==    mv >>= (\x -> (f x >>= g))

Сначала проверим закон для случая, когда mv = Nothing:

(Nothing >>= f) >>= g             -- с левой стороны
  = Nothing >>= g                 -- по определению >>=
  = Nothing                       -- по определению >>=

Nothing >>= (\x -> (f x >>= g))   -- с правой стороны
  = Nothing                       -- по определению >>=

Хорошо, проверка прошла успешно. Теперь посмотрим, работает ли для mv = Just v, где v - некоторое значение:

((Just v) >>= f) >>= g            -- с левой стороны
  = f v >>= g                     -- по определению >>=

(Just v) >>= (\x -> (f x >>= g))  -- с правой стороны
  = (\x -> (f x >>= g)) v         -- по определению >>=
  = f v >>= g                     -- нормальное применение функции (бета-редукция)

И тоже успешно. Значит, это работает! Это _действительно_ корректное определение монады Maybe! И публика сходит с ума!


